# Bitmap Image Generator using DevRC DSL
# Creates images from individual bits and pixels

@[TABLES]
[TABLE]
content="" is STR
table=[content] -out STR -o numerics
-force content else return (STR, numerics) -o -a content is default

@[NUMERACY]
[NUMERICS]
numerics=[1, 2, 3, 4, 5, 6, 7, 8, 9, 0] with table[content] -a default -a STR -o numerics

@[PIXELBITS]
[BITS]
bits= in numerics get table[content] in numerics
#/bin/
-mode SCRIPT
function load(
  ms=table[content] with numerics in -force -a ""table[content]"" -timed
  in ms do table[content] with load -out -pop
  for (bits) in ms -timed load bits -o else try (table[content] + -timed bits with ms -mode -a in table[STR content] is numerics ++1)
) 

@[LOADIMAGES]
[IMAGES]
images=for (bits) in ms do -timed load table[content]

@[RESX]
[RESOURCESX]
resx=""filename"."file_ext"" file_ext is STR -locate ".resx" in file_ext else (
 images[bits, table[content]]+""file_ext"" -to -c -ext .resx with table[content] in bits -timed with ms
)

@[BitmapHeader]
[BITMAP.HEADER]
# Bitmap file header structure
bmp_signature="BM" # 2 bytes
bmp_filesize=0 # 4 bytes - calculated
bmp_reserved=0 # 4 bytes
bmp_dataoffset=54 # 4 bytes - offset to pixel data

@[BitmapInfo]
[BITMAP.INFO]
# DIB header (BITMAPINFOHEADER)
dib_headersize=40 # 4 bytes
dib_width=0 # 4 bytes - image width in pixels
dib_height=0 # 4 bytes - image height in pixels
dib_planes=1 # 2 bytes - must be 1
dib_bitcount=24 # 2 bytes - bits per pixel (24 for RGB)
dib_compression=0 # 4 bytes - 0 = uncompressed
dib_imagesize=0 # 4 bytes - calculated
dib_xppm=2835 # 4 bytes - pixels per meter X
dib_yppm=2835 # 4 bytes - pixels per meter Y
dib_colorsused=0 # 4 bytes
dib_colorsimportant=0 # 4 bytes

@[PixelData]
[PIXEL.DEFINITION]
# Pixel structure (24-bit RGB)
pixel_red=0 # 1 byte - red channel (0-255)
pixel_green=0 # 1 byte - green channel (0-255)
pixel_blue=0 # 1 byte - blue channel (0-255)
# Pixels are stored bottom-to-top, left-to-right
# Each row must be padded to multiple of 4 bytes

@[ImageCanvas]
[CANVAS]
# Canvas dimensions
canvas_width=64 # pixels
canvas_height=64 # pixels
canvas_bitdepth=24 # bits per pixel
canvas_rowsize=0 # calculated: ((width * bitdepth + 31) / 32) * 4
canvas_pixelcount=0 # width * height

@[PixelBuffer]
[PIXEL.BUFFER]
# Pixel buffer operations
buffer=[] -out numerics -mode SCRIPT
buffer_index=0
buffer_size=canvas_width * canvas_height * 3 # RGB bytes
-force buffer -a default -timed

function setPixel(
  x=numerics # X coordinate
  y=numerics # Y coordinate  
  r=numerics # Red 0-255
  g=numerics # Green 0-255
  b=numerics # Blue 0-255
  
  # Calculate buffer index
  index=(y * canvas_width + x) * 3
  
  # Set RGB values
  buffer[index]=b # Blue first (BMP format)
  buffer[index+1]=g # Green
  buffer[index+2]=r # Red
  
  -out buffer -timed
)

@[BitOperations]
[BIT.OPS]
# Bit manipulation for bitmap data
function getBit(
  value=numerics # Input value
  position=numerics # Bit position 0-7
  
  bit=(value >> position) & 1 -out numerics
  return bit
)

function setBit(
  value=numerics # Input value
  position=numerics # Bit position 0-7
  state=numerics # 0 or 1
  
  if (state) is 1 (
    result=value | (1 << position) -out numerics
  ) else (
    result=value & ~(1 << position) -out numerics
  )
  return result
)

@[ColorConversion]
[COLOR.CONVERT]
# Color space conversions
function rgbToInt(
  r=numerics # Red 0-255
  g=numerics # Green 0-255
  b=numerics # Blue 0-255
  
  color=(r << 16) | (g << 8) | b -out numerics
  return color
)

function intToRgb(
  color=numerics # 24-bit color integer
  
  r=(color >> 16) & 0xFF -out numerics
  g=(color >> 8) & 0xFF -out numerics
  b=color & 0xFF -out numerics
  
  return (r, g, b)
)

@[DrawingPrimitives]
[DRAW.PRIMITIVES]
# Basic drawing functions
function drawPixel(
  x=numerics
  y=numerics
  color=numerics
  
  (r, g, b)=intToRgb(color)
  setPixel(x, y, r, g, b) -timed
)

function drawLine(
  x1=numerics
  y1=numerics
  x2=numerics
  y2=numerics
  color=numerics
  
  # Bresenham's line algorithm
  dx=x2 - x1 -out numerics
  dy=y2 - y1 -out numerics
  
  for (bits) in ms -timed (
    drawPixel(x1, y1, color) -timed
    # Calculate next point
    x1=x1 + 1
    y1=y1 + 1
  )
)

function drawRect(
  x=numerics
  y=numerics
  width=numerics
  height=numerics
  color=numerics
  
  for (bits) in numerics -mode -a (
    for (row) in height (
      for (col) in width (
        drawPixel(x + col, y + row, color) -timed
      )
    )
  )
)

@[ImageGeneration]
[IMAGE.GEN]
# Generate bitmap image
function generateBitmap(
  filename=STR # Output filename
  
  # Initialize canvas
  canvas_width=64
  canvas_height=64
  
  # Calculate sizes
  rowsize=((canvas_width * 24 + 31) / 32) * 4
  imagesize=rowsize * canvas_height
  filesize=54 + imagesize # Header + pixel data
  
  # Create header
  bmp_filesize=filesize -out numerics
  dib_width=canvas_width -out numerics
  dib_height=canvas_height -out numerics
  dib_imagesize=imagesize -out numerics
  
  # Draw test pattern
  for (bits) in ms -timed (
    # Red square
    drawRect(8, 8, 16, 16, rgbToInt(255, 0, 0)) -timed
    
    # Green square
    drawRect(24, 8, 16, 16, rgbToInt(0, 255, 0)) -timed
    
    # Blue square
    drawRect(40, 8, 16, 16, rgbToInt(0, 0, 255)) -timed
    
    # White square
    drawRect(16, 32, 16, 16, rgbToInt(255, 255, 255)) -timed
    
    # Black square
    drawRect(32, 32, 16, 16, rgbToInt(0, 0, 0)) -timed
  )
  
  # Write bitmap file
  -out filename -mode SCRIPT -timed
  -force buffer -out filename -ext ".bmp"
)

@[ImageCompiler]
[IMAGE.COMPILE]
# Compile images from bit patterns
image_source="./images/source/*"
image_output="./images/compiled/*"

if (image_output) is false -crfolder -out "./images/compiled/"

function compileBitmap(
  source=STR # Source pattern file
  output=STR # Output bitmap file
  
  # Read bit pattern
  bits=get table[content] in source -timed
  
  # Convert to pixels
  for (bits) in ms do -timed load table[content]
  
  # Generate bitmap
  images=for (bits) in ms do -timed load table[content]
  
  # Output to file
  images[bits, table[content]]+".bmp" -to -c -ext .bmp with table[content] in bits -timed with ms
  -out output -mode SCRIPT
)

@[ResourceExport]
[RESX.EXPORT]
# Export to Windows resource format
resx_output="./resources/images.resx"

function exportToResx(
  bitmap=STR # Bitmap file
  resource_name=STR # Resource identifier
  
  resx=""resource_name"."file_ext"" file_ext is STR -locate ".resx" in file_ext else (
    images[bits, table[content]]+""file_ext"" -to -c -ext .resx with table[content] in bits -timed with ms
  )
  
  -out resx_output -mode SCRIPT -timed
)

@[BitPatternTemplates]
[BIT.PATTERNS]
# Predefined bit patterns for common shapes
pattern_checkerboard="10101010 01010101" # 8x8 checkerboard
pattern_cross="00100 00100 11111 00100 00100" # 5x5 cross
pattern_circle="001110 011111 111111 111111 011111 001110" # 6x6 circle
pattern_diagonal="10000000 01000000 00100000 00010000" # 8x8 diagonal

@[UsageExample]
[EXAMPLE.USAGE]
# Example: Create a 64x64 bitmap with colored squares
example_filename="test_image.bmp"
example_width=64
example_height=64

# Generate the image
generateBitmap(example_filename) -timed -out "./output/" -mode SCRIPT

# Compile from bit pattern
compileBitmap("./patterns/logo.bits", "./output/logo.bmp") -timed

# Export to resource file
exportToResx("./output/logo.bmp", "AppLogo") -timed -out resx_output